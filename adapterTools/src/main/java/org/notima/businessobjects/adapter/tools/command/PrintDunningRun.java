package org.notima.businessobjects.adapter.tools.command;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.text.ParseException;
import java.util.Collection;
import java.util.Properties;

import javax.xml.bind.JAXB;

import org.apache.karaf.shell.api.action.Argument;
import org.apache.karaf.shell.api.action.Command;
import org.apache.karaf.shell.api.action.Completion;
import org.apache.karaf.shell.api.action.Option;
import org.apache.karaf.shell.api.action.lifecycle.Reference;
import org.apache.karaf.shell.api.action.lifecycle.Service;
import org.apache.karaf.shell.api.console.Session;
import org.apache.karaf.shell.support.completers.FileCompleter;
import org.notima.businessobjects.adapter.tools.FormatterFactory;
import org.notima.businessobjects.adapter.tools.InvoiceReminderFormatter;
import org.notima.businessobjects.adapter.tools.MessageSender;
import org.notima.businessobjects.adapter.tools.MessageSenderFactory;
import org.notima.generic.businessobjects.DunningEntry;
import org.notima.generic.businessobjects.DunningRun;
import org.notima.generic.businessobjects.Message;
import org.notima.generic.businessobjects.Person;
import org.notima.generic.businessobjects.exception.NoSuchTenantException;
import org.notima.generic.ifacebusinessobjects.KeyManager;
import org.notima.util.json.JsonUtil;
import org.osgi.framework.Bundle;
import org.osgi.framework.BundleContext;
import org.osgi.framework.FrameworkUtil;
import org.osgi.framework.ServiceReference;

@Command(scope = "notima", name = "print-dunning-run", description = "Prints dunning run from a file (can be generated by dunning-run)")
@Service
public class PrintDunningRun extends AbstractAction {
	
	@Reference 
	Session sess;
	
	@Reference
	private FormatterFactory	formatterFactory;
    
	private String				format = "pdf";
	
	private InvoiceReminderFormatter	formatter;
	
    @Option(name="-s", description="Sends invoices by e-mail if applicable", required = false, multiValued = false)
    private boolean	sendByEmail;

    @Option(name="-a", description="If set, all e-mails go to this address", required = false, multiValued = false)
    private String	recipientAddress;
    
    @Option(name = "-e", aliases = { "--encrypt" }, description = "Send encrypted email.", required = false, multiValued = false)
    private boolean encrypt;
    
    @Option(name="-od", description="Output directory (where files are placed)", required = false, multiValued = false)
    private String	outputDirectory;
    
	@Argument(index = 0, name = "fileName", description ="File with invoice information", required = true, multiValued = false)
	@Completion(FileCompleter.class)   
	private String invoiceFile = "";
	
	private DunningRun<?,?> dunningRun = null;
	private Properties props = new Properties();
	
	private MessageSender emailSender;	
	
	private boolean attachPublicKey;
	private String		  emailBody;
	private String		  subject;
	
	@Override
	protected Object onExecute() throws Exception {
		
		initFormatterFactory();
		parseOptions();

		printDunningRun();
		
		return null;
	}
	
	private void initFormatterFactory() throws Exception {

		formatter = formatterFactory.getInvoiceReminderFormatter(format);
		
	}
	
	private void parseOptions() throws ParseException, NoSuchTenantException, Exception {

		parseInvoiceFile();
		
		props.setProperty("JasperFile", 
				"/home/daniel/develop/notima-workspace/businessObjectAdapters/jasperReportAdapter/src/main/resources/reports/InvoiceReminder.jasper");
		
		if (outputDirectory==null) {
			outputDirectory = new File(invoiceFile).getParent();
		}
		
		props.setProperty("JasperOutputDir", outputDirectory);
		
		if (sendByEmail) {
			emailSender = getMessageSenderFactory().getMessageSender("email");
			
			if (emailSender==null)
				throw new Exception("No message sender available");
			
			emailBody = "Se bilaga. Kontakta oss vid ev fr책gor. 08 776 31 30 eller svara p책 mailet.";
		}
	}
	
	
	private void printDunningRun() throws Exception {
		
		Collection<DunningEntry<?,?>> invoices = dunningRun.getEntries();
		
		for (DunningEntry<?,?> ii : invoices) {
			printInvoice(ii);
		}
		
	}
	
	private void printInvoice(DunningEntry<?,?> entry) throws Exception {
		
		// jasperLang = props.getProperty(JASPER_LANG);
		
		String outputFilename = getFileNameForEntry(entry);
		
		props.setProperty("JasperOutputFilename", outputFilename);
		
		String path = formatter.formatReminder(entry, format, props);
		sess.getConsole().println(path);
		
		if (sendByEmail) {
			sendByEmail(entry, path);
		}
		
	}
	
	private void sendByEmail(DunningEntry<?,?> entry, String path) throws Exception {
		
		if (entry.getDebtor().isEmailInvoice()) {
			
			String recipient = (recipientAddress!=null ? recipientAddress : getEmail(entry));
			subject = "P책minnelse fr책n " + entry.getCreditor().getName() + " -";
			if (recipient!=null) {

		        Message message = new Message();
		        Person recipientPerson = new Person();
		        recipientPerson.setEmail(recipient);
		        message.setBody(emailBody);
		        message.setRecipient(recipientPerson);
		        message.setSubject(subject + " " + entry.getLetterNo());
		        message.setContentType("text/html;charset=utf-8");
		        
	        	message.addAttachment(new File(path));

		        emailSender.send(message, getPGPService(), attachPublicKey);

		        sess.getConsole().println(subject + " sent successfully to "+ recipient + (encrypt ? " using PGP-encryption" : ""));
				
				
			}
			
		}
		
	}
	
	private String getEmail(DunningEntry<?,?> de) {
		String email = null;
		if (de.getDebtor().getAddressOfficial()!=null) {
			email = de.getDebtor().getAddressOfficial().getEmail();
		}
		if (de.getDebtor().getContacts()!=null && de.getDebtor().getContacts().size()>0) {
			for (Person p : de.getDebtor().getContacts()) {
				if (p.getEmail()!=null) {
					email = p.getEmail();
					break;
				}
			}
		}
		if (email==null && de.getDebtor().getAddressShipping()!=null) {
			email = de.getDebtor().getAddressShipping().getEmail();
		}
		return email;
	}
	
	private String getFileNameForEntry(DunningEntry<?,?> de) {
		
		StringBuffer buf = new StringBuffer();
		buf.append(de.getLetterNo());
		String email = getEmail(de);
		if (email!=null && de.getDebtor().isEmailInvoice()) {
			buf.append("-email");
		}

		return buf.toString();
	}
	
	
	private void parseInvoiceFile() throws IOException {

		if (invoiceFile.toLowerCase().endsWith("xml")) {
			parseInvoiceXMLFile();
		}
		if (invoiceFile.toLowerCase().endsWith("json")) {
			parseInvoiceJsonFile();
		}
		
	}
	
	private void parseInvoiceJsonFile() throws IOException {
		
		FileReader fis = new FileReader(invoiceFile);
		dunningRun = JsonUtil.buildGson().fromJson(fis, DunningRun.class);
		fis.close();
		
	}
	
	private void parseInvoiceXMLFile() throws IOException {
		
		FileInputStream fis = new FileInputStream(invoiceFile);
		dunningRun = JAXB.unmarshal(fis, DunningRun.class);
		fis.close();
		File f = new File(invoiceFile);
		System.setProperty("DUNNING_XML", f.getAbsolutePath());
		
	}
	
	
    private MessageSenderFactory getMessageSenderFactory() {
        return (MessageSenderFactory) getServiceReference(MessageSenderFactory.class);
    }

    private KeyManager getPGPService() {
		return (KeyManager) getServiceReference(KeyManager.class);
    }
    
	protected <S> Object getServiceReference(Class<S> clazz) {
		Bundle bundle = FrameworkUtil.getBundle(getClass());
		if (bundle != null) {
			BundleContext ctx = bundle.getBundleContext();
			ServiceReference<S> reference = ctx
					.getServiceReference(clazz);
			if (reference != null)
				return ctx.getService(reference);
		}
		return null;
    }
	
	
}
