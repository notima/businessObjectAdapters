package org.notima.businessobjects.adapter.tools.command;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.text.ParseException;
import java.util.List;
import java.util.Properties;

import javax.xml.bind.JAXB;

import org.apache.karaf.shell.api.action.Argument;
import org.apache.karaf.shell.api.action.Command;
import org.apache.karaf.shell.api.action.Completion;
import org.apache.karaf.shell.api.action.Option;
import org.apache.karaf.shell.api.action.lifecycle.Reference;
import org.apache.karaf.shell.api.action.lifecycle.Service;
import org.apache.karaf.shell.api.console.Session;
import org.apache.karaf.shell.support.completers.FileCompleter;
import org.notima.businessobjects.adapter.tools.FormatterFactory;
import org.notima.businessobjects.adapter.tools.InvoiceFormatter;
import org.notima.businessobjects.adapter.tools.MessageSender;
import org.notima.businessobjects.adapter.tools.MessageSenderFactory;
import org.notima.generic.businessobjects.Invoice;
import org.notima.generic.businessobjects.InvoiceList;
import org.notima.generic.businessobjects.Message;
import org.notima.generic.businessobjects.Person;
import org.notima.generic.businessobjects.exception.NoSuchTenantException;
import org.notima.generic.ifacebusinessobjects.KeyManager;
import org.notima.util.json.JsonUtil;
import org.osgi.framework.Bundle;
import org.osgi.framework.BundleContext;
import org.osgi.framework.FrameworkUtil;
import org.osgi.framework.ServiceReference;

@Command(scope = "notima", name = "print-invoices", description = "Prints invoices from a file (can be generated by read-invoices)")
@Service
public class PrintInvoices extends AbstractAction {
	
	@Reference 
	Session sess;
	
	@Reference
	private FormatterFactory	formatterFactory;
    
	private String				format = "pdf";
	
	private InvoiceFormatter	formatter;
	
    @Option(name="-s", description="Sends invoices by e-mail if applicable", required = false, multiValued = false)
    private boolean	sendByEmail;

    @Option(name="-a", description="If set, all e-mails go to this address", required = false, multiValued = false)
    private String	recipientAddress;
    
    @Option(name = "-e", aliases = { "--encrypt" }, description = "Send encrypted email.", required = false, multiValued = false)
    private boolean encrypt;
    
    @Option(name="-od", description="Output directory (where files are placed)", required = false, multiValued = false)
    private String	outputDirectory;
    
	@Argument(index = 0, name = "fileName", description ="File with invoice information", required = true, multiValued = false)
	@Completion(FileCompleter.class)   
	private String invoiceFile = "";
	
	private InvoiceList invoiceList = null;
	private Properties props = new Properties();
	
	private MessageSender emailSender;	
	
	private boolean attachPublicKey;
	private String		  emailBody;
	private String		  subject;
	
	@Override
	protected Object onExecute() throws Exception {
		
		initFormatterFactory();
		parseOptions();

		printInvoices();
		
		return null;
	}
	
	private void initFormatterFactory() throws Exception {

		formatter = formatterFactory.getInvoiceFormatter(format);
		
	}
	
	private void parseOptions() throws ParseException, NoSuchTenantException, Exception {

		parseInvoiceFile();
		
		props.setProperty("JasperFile", 
				"/home/daniel/develop/notima-workspace/businessObjectAdapters/jasperReportAdapter/src/main/resources/reports/InvoiceBasic.jasper");
		
		if (outputDirectory!=null) props.setProperty("JasperOutputDir", outputDirectory);
		
		if (sendByEmail) {
			emailSender = getMessageSenderFactory().getMessageSender("email");
			
			if (emailSender==null)
				throw new Exception("No message sender available");
			
			subject = "Avi från " + invoiceList.getCreditor().getName();
			emailBody = "<p>Se bifogad avi.<br>" + "Kontaktuppgifter till " + invoiceList.getCreditor().getName() + " i bifogad PDF.</p>" + 
			            "<p>Vid frågor om själva utskicket, kontakta oss på 08 776 31 30 eller svara på mailet.</p>" +
					    "<p>Ekonomibolaget Notima AB</p>";
			
		}
	}
	
	
	private void printInvoices() throws Exception {
		
		List<Invoice<?>> invoices = invoiceList.getInvoiceList();
		
		for (Invoice<?> ii : invoices) {
			printInvoice(ii);
		}
		
	}
	
	private void printInvoice(Invoice<?> invoice) throws Exception {
		
		// jasperLang = props.getProperty(JASPER_LANG);
		
		String outputFilename = getFileNameForInvoice(invoice);
		
		props.setProperty("JasperOutputFilename", outputFilename);
		
		String path = formatter.formatInvoice(invoice, format, props);
		sess.getConsole().println(path);
		
		if (sendByEmail) {
			sendByEmail(invoice, path);
		}
		
	}
	
	private void sendByEmail(Invoice<?> invoice, String path) throws Exception {
		
		if (invoice.getBusinessPartner().isEmailInvoice()) {
			
			String recipient = (recipientAddress!=null ? recipientAddress : invoice.getBillEmail());
			if (recipient!=null) {

		        Message message = new Message();
		        Person recipientPerson = new Person();
		        recipientPerson.setEmail(recipient);
		        message.setBody(emailBody);
		        message.setRecipient(recipientPerson);
		        message.setSubject(subject + " " + invoice.getDocumentKey());
		        message.setContentType("text/html;charset=utf-8");
		        
	        	message.addAttachment(new File(path));

		        emailSender.send(message, getPGPService(), attachPublicKey);

		        sess.getConsole().println(subject + " sent successfully to "+ recipient + (encrypt ? " using PGP-encryption" : ""));
				
				
			}
			
		}
		
	}
	
	
	private String getFileNameForInvoice(Invoice<?> invoice) {
		
		StringBuffer buf = new StringBuffer();
		buf.append(invoice.getDocumentKey());
		String email = invoice.getBillEmail();
		if (email!=null && invoice.getBusinessPartner().isEmailInvoice()) {
			buf.append("-email");
		}

		return buf.toString();
	}
	
	
	private void parseInvoiceFile() throws IOException {

		if (invoiceFile.toLowerCase().endsWith("xml")) {
			parseInvoiceXMLFile();
		}
		if (invoiceFile.toLowerCase().endsWith("json")) {
			parseInvoiceJsonFile();
		}
		
	}
	
	private void parseInvoiceJsonFile() throws IOException {
		
		FileReader fis = new FileReader(invoiceFile);
		invoiceList = JsonUtil.buildGson().fromJson(fis, InvoiceList.class);
		fis.close();
		
	}
	
	private void parseInvoiceXMLFile() throws IOException {
		
		FileInputStream fis = new FileInputStream(invoiceFile);
		invoiceList = JAXB.unmarshal(fis, InvoiceList.class);
		fis.close();
		File f = new File(invoiceFile);
		System.setProperty("INVOICELIST_XML_FILE", f.getAbsolutePath());
		
	}
	
	
    private MessageSenderFactory getMessageSenderFactory() {
        return (MessageSenderFactory) getServiceReference(MessageSenderFactory.class);
    }

    private KeyManager getPGPService() {
		return (KeyManager) getServiceReference(KeyManager.class);
    }
    
	protected <S> Object getServiceReference(Class<S> clazz) {
		Bundle bundle = FrameworkUtil.getBundle(getClass());
		if (bundle != null) {
			BundleContext ctx = bundle.getBundleContext();
			ServiceReference<S> reference = ctx
					.getServiceReference(clazz);
			if (reference != null)
				return ctx.getService(reference);
		}
		return null;
    }
	
	
}
